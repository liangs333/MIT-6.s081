虽然lec是关于interrupt的，但是lab和这个并没有什么关系
lab做的还是VM、pageFault的那一块内容。

整个lab只有一个task，即实现copy_on_write
    具体来说，在fork一个proc的时候，并不直接拷贝其中的所有资源，而是把子进程的pageTable整成和父进程一样的。
    那么，类比于主席树，在进行修改的时候，我们希望此处的“历史版本”，即父子进程中的另一个能够访问到原先的数据
    那么，在修改时新建节点并拷贝，就是一个比较好想到的方法了。
    主席树并不需要处理节点回收，但是OS需要，所以还需要一些方法来让我们能够在该回收一个节点的时候真正回收他。
    顺带一提，这里也是我第一次接触到锁这个东西。

这里我们手动切分一下subtask

subtask1
    改一改fork，让OS在fork的时候并不真实地复制所有资源，而是像上述描述到的，进行一个重复映射地址

subtask1_sol
    发觉有一个叫uvmcopy的函数会被fork调用，把这个改了，原先是kalloc一个page，然后memmove，然后mappage，现在直接快进到mappage
    由于我们不是很希望这两个或者多个va对应的一个pa真正被修改，所以需要关掉对应多个PTE里的pte_W，并且搞个PTE_C标志位来标记这个PTE是COW产生的
    在这里建议做一些assert之类的事情，来检测写码的时候 脑子是否是清醒的。

subtask2
    修改usertrap，使得由于上述原因产生的usertrap能够良好地被解决

subtask2_sol
    方案还蛮简单的，在PA里kalloc一块儿，从原先的PA把数据memmove过来，然后把PTE指过去，打开PTE_W，关掉PTE_C就好
    但是要注意，传进来的VA是不是真的有PTE可以对应，以及这个PTE是不是真的是COW搞出来的不能写的PTE
    以及要注意位运算有没有敲歪来（bushi

subtask3
    设计合理的内存回收机制，避免有些page最后莫名找不到了

subtask3_sol
    这里其实会引出一个我们刚刚并没有考虑仔细的问题，即 什么时候才能真正free一个page？
    当没有任何一条PTE指向他的时候，我们才可以科学合理地free他，否则一定会影响到某个userProc
    如何获得每个Page被多少个PTE指向这个信息呢？
    根据经验，可以在某个地方搞个int pageUseCount[PAGENUMBER]数组
    然后在kalloc的时候++，在uvmcopy的时候++，在trap机制里，赋值page之后--
    然后在--到他该被free的时候就把他给free了就好。
    由于显然存在并发，这个数组需要被锁保护
    可以通过魔改kfree来达到这个计数的效果
    然后会报panic，因为在某个初始化函数里调用了kfree，我们应该先给每个用到的page赋一个usecount才行。
    
    最后由于copyout可以绕开usertrap进行访问内存，我们需要在copyout那里也做相应的处理
    即 看看是不是COW弄出来的没法写，如果是，那么进行一个复制

emm写的时候被文件结构搞得很焦头烂额，为什么函数放在这里就能编译，放在隔壁就不行，蛮毛躁的还
不过还好最后写出来了，可以发觉最后代码的结构很诡异HH
收获的话，多加panic吧，对于不是很想用gdb来调试这东西的我来说，看到系统的panic大概率是不知道发生了什么的
而看到自己加上去的“panic : GG in uvmcopy”的时候，就感觉事情一下子好起来了HH
