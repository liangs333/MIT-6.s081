在这堂lec里，Frans教授主要讲了有关于锁的一些特性和用法，还带着我们看了一下spinlock的实现。
首先要意识到，在现代的计算机上，我们往往需要支持并发。
即，多个proc可能同时运行在不同的CPU核心上，在物理意义上同时地对同一个东西进行修改/查询
这是一个很复杂的事情，如果一开始就去考虑实际上的并发，会感觉头晕目眩即将昏迷
为此，我们考虑一种更简单的理解方式————假装只有一个CPU。
依据在上述课程中学到的proc相关的知识，如interrupt、trap等，我们知道，在计算机内，即使只有一个cpu，也可以在上面进行多个proc的切换，来达到“事情看起来是并行的”的效果。
在理解多核CPU运行遇到严重困难时，不妨试试上述的 简化后的想法，即，我们没有多个CPU，但是有多个线程。会由TimerInterrupt强制CPU在多个proc之间切换
在这种较为简化的视角下，或许我们能够更轻松的理解和学习本lec的内容。

言归正传。
先看一个例子，关于如果没有锁 会带来的哪些不愉快的事情。
比如内存管理系统中的freelist，是一个标记了PA中哪些page没有被使用的链表
更新链表的步骤有三步
    new node;
    node.next = list.head
    list.head = &node
如果这里有两个CPU并发执行，且他俩的指令是完全按顺序，1 1 2 2 3 3 这样执行的，那么执行完之后，我们就丢了一个page。
原因很显然——并没有一个指针指向第一个新建的node
在cpu更多的时候，还会发生更多不愉快的事儿。
为什么呢？
    原因是显然的————我们的更新数据结构的指令并不是一个整体，中间可能混进去了奇奇怪怪的东西
    在我们完成更新之前，数据结构的关键信息发生了变化，而我们使用了过期版本的关键信息去更新DS
    我们称这种多个proc并发使用同一套信息的情况叫竞态 race condition
解决这事情最常见的方法就是使用锁。
锁，顾名思义，把我们正在修改的无论什么东西关起来，锁起来，不让别人看到。
一般用于保护一些数据/数据结构，使得他在某个时间段专属于某个线程。
锁的使用，acquire和release，这里不再赘述。
acquire和release之间的代码，我们称之为criticalSection

关于如何加锁的一个指导思想
    两个进程访问了一个共享的数据结构
    并且其中一个会对数据结构进行更新
    那就加锁

一个栗子
    rename ("d1/x", "d2/y");
    如果按照下面的顺序执行，会出锅
    acquire("d1");
    erase
    release()

    acquire("d2")
    add
    release()
    假设在第一个release和第二个acquire之间出现了intr，那么，文件消失了。
    所以应该
    acquire * 2
    move
    release * 2
蛮有意思的一个例子

死锁：
    最简单的死锁
        一个进程两次acquire同一个锁，显然会死锁，因为第二次永远也拿不到

    不那么简单的死锁
        proc1: acquire(a, b)
        proc2: acquire(b, a)
    假设他俩真并发了，哦豁
    这告诉我们，拿锁需要按顺序，先给锁排序，再挨个申请，包括子函数调用内的拿锁，也需要按顺序。
    某种程度上破坏了封装，因为调用者本来只需要一个接口，根本不需要知道内部的实现。

    事实上并不需要对所有的锁有一个大排序，因为有些锁对这辈子都不会被一个proc同时acquire
    会形成一个有限偏序集长相的东西，但是其实做成全序也不影响。

锁与开发：
    从大到小，从粗粒度到细粒度，保证程序能跑的情况下，尽可能的精细
    没实际写过什么锁编程，就不在这里瞎讲了

UART驱动中的锁应用
    可以很清晰的看到，锁在这里保护了buffer，使得多个并发的进程不会搞掉什么数据
    其他的略

spinlock的实现：
    顾名思义，spinlock，自旋锁
    没拿到就在那转转转
    实现技巧上，很讲究原子性

    先来看一个假了的spinlock
        fake_acquire(lock *a)
            while(1) {
                if(a.locked == 0) {
                    a.locked = 1;
                    return;
                }
            }
    会发生什么呢？在if和赋值之间，可能有intr，然后俩进程同时获取了同一把锁
    在xv6中，锁的实现依赖了硬件提供的 具有原子性的指令。
    amoswap atomoc memory swap
    不仅在acquire，release也是一样的。
    release为啥不用store？因为store不是原子指令。
    
    以及，在acquire函数里，我们需要关闭中断，最终在release的时候打开
    原因显然是为了防止死锁

关于锁与编译器：
    编译器会通过重排代码的方式来进行性能优化
    我们显然不希望代码从criticalSection里跑到外面去或者反之
    因此，锁的acquire和release都包含了synchronize指令
    某种意义上 对于编译器的一个屏障，不准把代码跨越这根线
    
