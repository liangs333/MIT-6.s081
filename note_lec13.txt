本次lec的重点是coordination，不是很清楚翻译成中文叫什么。
设想这样一个场景，某个proc在等待某个事情发生，在对应事情发生前的这段时间他什么也干不了。

一个笨办法显然是while(无事发生)，但如果对于某个可能在明儿个发生的事件，这属于浪费资源。
但是Robert有提到，如果该事件极有可能在非常短的时间内发生，那么这种编程策略，也许，还不错？
用原话讲叫“或许是一个最正确的方式”

而更多的时候，这个proc将会处于一个while(没有输入)中长达几秒甚至几分钟
这个时候，我们希望能有一种方法，使得他出让cpu，并且搁旁边趴着
直到他等待的事件发生，再通过某种方式被唤醒，接着做手头的事情。
让我们介绍一下sleep和wakeup

在xv6里，sleep的接口是长这样的 sleep(chan, &lock)
chan可以理解，作为某个事件对应的编码，在对应事件发生时，通过调用wakeup(chan)来唤醒sleep的proc
但是lock就比较令人迷惑了，我只是想sleep，干嘛传个lock进去
而这堂lec完美地解决了这个困惑，让我们接着往下看好了。

假设有一个sleep_naive(chan)，是一个新写的接口，朴实，无华，枯燥，并不需要传一个锁
不难想象，在很多需要sleep的时候，我们所等待的“某个事件”的形式为“某个DS发生改变”，而我们面对的显然是一个需要协同合作的数据结构
协同合作+非原子修改 = 加锁
所以sleep代码应该是会长成这样
    while(1) {
        acquire(&lock);
        if(checkIfHappened() == 0) {
            release(&lock);
            sleep_naive(chan);
        }
        else {
            release(&lock);
            break_and_go_to_do_some_thing;
        }
    }
问题出现在第25和26行之间。
如果在这里，恰好发生了一个timerInterrupt
且，在当前proc再一次运行之前，我们所等待的事件已经发生了
即，已经有另外的proc调用了wakeup(chan)
那，当前proc就彻底的 昏迷过去了。

这种情况被称为lost wakeup
顾名思义，有一个wakeup丢失了，并没有唤醒期望被它唤醒的东西。
究其原因，我们会发现，问题出自25 26这两行代码的原子性，他们并不是必然连续执行的
我们需要某种机制保证这一点，以求我们不会遭遇lost wakeup错误。
而这种机制就是当前sleep的设计。
在sleep(chan, &lock)机制中，通过巧妙的顺序保证了，当前proc在触发sched之前，总是持有至少一个锁的。
由于sched需要proc持有且仅持有p->lock，不难想象这段代码是怎么写的。
而在从sched回来后，即，事情已经被解决后，我们会重新acquire这个传进去的锁

而关于为什么我们一般要把sleep包裹在while里面，是因为，可能有多个proc正在观测同一个事件，并且这些proc的下一步行动都会消耗对应资源。
wakeup会一次性唤醒所有等待事件的proc，其中一个幸运的会拿到资源，另外一大车倒霉的会接着去睡觉。

后续讲到了有关exit wait kill的实现细节

在设计exit和kill时，会遇到一些麻烦。
首先，我们不希望从外部大力摧毁一个线程，因为他可能正在进行一些“期望是原子的”操作，直接干掉他会发生不好的事情。
其次，线程自己不太能 干掉自己，因为程序运行时会难以避免的持有一些程序运行所必备的资源。
带着这两个麻烦，我们来欣赏关于exit kill wait的设计

在exit里，proc自身关掉所有文件描述符，把所有子进程的父亲设置为initProc，把自己是status设置为zombie，然后开润
可能会发觉，这个proc当前的状态还是ZOMBIE，并不是UNUSED，还需要其他proc帮帮他。
在xv6的设计中，这个帮帮他的proc会是他的父亲。
理论上，exit是会伴随wait的，在父进程那里会有一个wait，等待着子进程的退出。
在找儿子这方面很简单暴力，扫描procs，找到father是自己，且zombie的proc。
然后调用freeproc，显然期间需要加锁什么的
freeproc会释放儿子的trapframe什么的，并且把proc这个结构体里面的东西还原到UNUSED状态。
所以不难发现，wait其实是exit的一个重要组成部分，由proc的父亲完成。

关于kill，我们kill一个进程实际上是采用了一种比较温和的方式，即，给他打个标记，告诉他，他死了（bushi
如果该进程整在睡觉，那么会顺手唤醒一下。

